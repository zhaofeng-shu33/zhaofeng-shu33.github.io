<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>c++_lemon_how_to_copy_a_graph_preserving_the_node_id</title>
    <link rel="stylesheet" href="../../../css/github-markdown.css">
    <style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
</style>
  </head>
  <article class="markdown-body">
	<h1>c++ lemon how to copy a graph preserving the node id</h1>
<p>2019/08/11</p>
<p>C++ lemon library provides a copy class <a href="http://lemon.cs.elte.hu/pub/doc/1.2.3/a00107.html">DigraphCopy</a>. However, this class does not preserve the node id between the newly created graph and old graph.
To preserve the node id, we can manually create and delete the nodes for the new graph. Below is the function to make such copy happen:
```C++</p>
<h1>include <lemon/list_graph.h></h1>
<p>using namespace lemon;
typedef ListDigraph::ArcMap<double> ArcMap;
typedef ListDigraph::Node Node;
typedef ListDigraph::Arc Arc;
void digraph_copy(const ListDigraph&amp; oldGraph, const ArcMap&amp; oldArcMap, ListDigraph&amp; G, ArcMap&amp; A){
  for(int i = 0; i &lt;= oldGraph.maxNodeId(); i++)
    G.addNode();
  for(ListDigraph::NodeIt n(G); n != INVALID; ++n){
    if(!oldGraph.valid(n))
       G.erase(n);
  }
  for(ListDigraph::ArcIt a(oldGraph); a != INVALID; ++a){
    Arc a1 = G.addArc(oldGraph.source(a), oldGraph.target(a));
    A[a1] = oldArcMap[a];
  } 
}
<code>example usage:</code>C++</p>
<h1>include <iostream></h1>
<p>int main(){
  ListDigraph G1;
  ArcMap A1(G1);
  Node n0 = G1.addNode();
  Node n1 = G1.addNode();
  Node n2 = G1.addNode();
  Arc a01 = G1.addArc(n0, n1);
  Arc a02 = G1.addArc(n0, n2);
  A1[a01] = 3;
  A1[a02] = 4;
  G1.erase(n1);
  ListDigraph G2;
  ArcMap A2(G2);
  digraph_copy(G1, A1, G2, A2);
  std::cout &lt;&lt; countNodes(G2) &lt;&lt; std::endl;
  std::cout &lt;&lt; countArcs(G2) &lt;&lt; std::endl;
  for(ListDigraph::NodeIt n(G2); n != INVALID; ++n){
    std::cout &lt;&lt; G2.id(n) &lt;&lt; std::endl;
  }
  for(ListDigraph::ArcIt a(G2); a != INVALID; ++a){
    std::cout &lt;&lt; G2.id(G2.source(a)) &lt;&lt; ' ' &lt;&lt; G2.id(G2.target(a)) &lt;&lt; std::endl;
    std::cout &lt;&lt; A2[a] &lt;&lt; std::endl;
  }
  return 0;
}
```</p>
  <div style="text-align:center"><a href="https://zhaofeng-shu33.github.io">主页</a></div>
</article>
</html>
